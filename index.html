<!DOCTYPE html>
<html>
<head>
  <title>Nuyina Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.geodesic@2.7.1/dist/leaflet.geodesic.umd.min.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #controls {
      position: absolute; top: 10px; right: 10px; background: white;
      padding: 12px; z-index: 1000; border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3); font-family: sans-serif; font-size: 14px;
      max-height: 90vh; overflow-y: auto; min-width: 220px;
    }
    #controls label { display: block; margin: 8px 0 4px; }
    #controls select, #controls input[type=text] { width: 100%; padding: 4px; box-sizing: border-box; }
    #controls input[type=range] { width: 100%; }
    #controls button { margin-top: 10px; width: 100%; padding: 6px; }
    .val { float: right; font-weight: bold; }
    hr { margin: 10px 0; border: none; border-top: 1px solid #ddd; }
    #info { margin-bottom: 8px; }
    #customCoords { display: none; margin-top: 6px; }
    #customCoords input { width: 45%; display: inline-block; }
    .stats { font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <strong>Nuyina Tracker</strong>
    <div id="info">Loading...</div>
    <hr>

    <label>Voyage:
      <select id="voyage"></select>
    </label>

    <label>Target:
      <select id="target"></select>
    </label>
    <div id="customCoords">
      <input type="text" id="customLat" placeholder="Lat (e.g. -43.05)">
      <input type="text" id="customLon" placeholder="Lon (e.g. 147.34)">
      <button id="applyCustom" style="margin-top:4px">Apply</button>
    </div>

    <hr>

    <label>Records: <span class="val" id="countVal">500</span></label>
    <input type="range" id="count" min="50" max="40000" step="50" value="500">

    <label>Interval (min): <span class="val" id="intervalVal">60</span></label>
    <input type="range" id="interval" min="1" max="1800" step="10" value="60">

    <hr>

    <label><input type="checkbox" id="showCrow" checked> Show crow lines</label>
    <label><input type="checkbox" id="useGC"> Great circle</label>

    <hr>

    <div id="stats" class="stats"></div>

    <button id="refresh">Refresh</button>
  </div>

  <script>
    // ---- State ----
    let voyagesData = null;
    let target = { lat: -42.88, lon: 147.33, name: 'Hobart' };  // default
    const map = L.map('map').setView([-43.5, 147.5], 9);
    let trackLayer = L.layerGroup().addTo(map);
    let targetMarker = null;

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap'
    }).addTo(map);

    // ---- Haversine ----
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2)**2 +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // ---- Load voyages.json ----
    async function loadVoyages() {
      try {
        const resp = await fetch('https://github.com/mdsumner/uwy.new/releases/download/v0.0.1/voyages_draft.json');
        voyagesData = await resp.json();
        populateVoyageDropdown();
        populateTargetDropdown();
      } catch (e) {
        console.error('Failed to load voyages:', e);
        // fallback: just load track with defaults
        loadTrack();
      }
    }

    // ---- Populate voyage dropdown ----
    function populateVoyageDropdown() {
      const sel = document.getElementById('voyage');
      sel.innerHTML = '<option value="live">Live (recent)</option>';

      if (!voyagesData?.voyages) return;

      // most recent first
      const voyages = [...voyagesData.voyages].reverse();
      voyages.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.id;
        const startDate = v.start ? new Date(v.start).toLocaleDateString() : '?';
        opt.textContent = `${v.id} â€” ${startDate}`;
        if (v.note) opt.title = v.note;
        sel.appendChild(opt);
      });
    }

    // ---- Populate target dropdown ----
    function populateTargetDropdown() {
      const sel = document.getElementById('target');
      sel.innerHTML = '';

      // add ports
      if (voyagesData?.ports) {
        const portsGroup = document.createElement('optgroup');
        portsGroup.label = 'Ports';
        Object.entries(voyagesData.ports).forEach(([name, p]) => {
          const opt = document.createElement('option');
          opt.value = JSON.stringify({ lat: p.lat, lon: p.lon, name });
          opt.textContent = name;
          portsGroup.appendChild(opt);
        });
        sel.appendChild(portsGroup);
      }

      // add recent stops from voyages
      if (voyagesData?.voyages) {
        const stopsGroup = document.createElement('optgroup');
        stopsGroup.label = 'Recent Stops';
        const seen = new Set();

        // reverse to get most recent voyages first
        [...voyagesData.voyages].reverse().slice(0, 5).forEach(v => {
          (v.stops || []).forEach(s => {
            const key = `${s.port}-${v.id}`;
            if (!seen.has(key)) {
              seen.add(key);
              const port = voyagesData.ports?.[s.port];
              if (port) {
                const opt = document.createElement('option');
                opt.value = JSON.stringify({ lat: port.lat, lon: port.lon, name: s.port });
                const date = s.depart ? new Date(s.depart).toLocaleDateString() :
                             s.arrive ? new Date(s.arrive).toLocaleDateString() : '';
                opt.textContent = `${s.port} â€” ${v.id} ${date}`;
                stopsGroup.appendChild(opt);
              }
            }
          });
        });
        if (stopsGroup.children.length) sel.appendChild(stopsGroup);
      }

      // custom option
      const customOpt = document.createElement('option');
      customOpt.value = 'custom';
      customOpt.textContent = 'âŠ• Custom location...';
      sel.appendChild(customOpt);

      // set default to Hobart if present
      const hobartOpt = sel.querySelector('option[value*="Hobart"]');
      if (hobartOpt) {
        hobartOpt.selected = true;
        target = JSON.parse(hobartOpt.value);
      }
    }

    // ---- Get voyage time bounds ----
    function getVoyageBounds(voyageId) {
      if (!voyagesData?.voyages) return null;
      const v = voyagesData.voyages.find(voy => voy.id === voyageId);
      if (!v) return null;
      return {
        start: v.start ? new Date(v.start) : null,
        end: v.end ? new Date(v.end) : null
      };
    }

    // ---- Build WFS URL ----
    function buildWfsUrl(count, voyageId) {
      const params = {
        service: 'WFS',
        version: '2.0.0',
        request: 'GetFeature',
        typeName: 'underway:nuyina_underway',
        outputFormat: 'application/json',
        sortBy: 'datetime D',
        count: count
      };

      // if specific voyage selected, add time filter
      if (voyageId && voyageId !== 'live') {
        const bounds = getVoyageBounds(voyageId);
        if (bounds) {
          let cql = [];
          if (bounds.start) cql.push(`datetime >= '${bounds.start.toISOString()}'`);
          if (bounds.end) cql.push(`datetime <= '${bounds.end.toISOString()}'`);
          if (cql.length) params.cql_filter = cql.join(' AND ');
        }
      }

      return 'https://data.aad.gov.au/geoserver/ows?' + new URLSearchParams(params);
    }

    // ---- Load and display track ----
    function loadTrack() {
      const count = document.getElementById('count').value;
      const interval = document.getElementById('interval').value * 60 * 1000;
      const showCrow = document.getElementById('showCrow').checked;
      const useGC = document.getElementById('useGC').checked;
      const voyageId = document.getElementById('voyage').value;

      document.getElementById('countVal').textContent = count;
      document.getElementById('intervalVal').textContent = document.getElementById('interval').value;

      trackLayer.clearLayers();

      // add target marker
      targetMarker = L.marker([target.lat, target.lon])
        .addTo(trackLayer)
        .bindPopup(target.name || 'Target');

      const wfsUrl = buildWfsUrl(count, voyageId);

      fetch(wfsUrl)
        .then(r => r.json())
        .then(data => {
          const features = data.features;
          if (!features || !features.length) {
            document.getElementById('info').innerHTML = 'No data for selection';
            return;
          }

          // filter to intervals
          const selected = [];
          let lastTime = null;
          for (const f of features) {
            const t = new Date(f.properties.datetime);
            if (!lastTime || (lastTime - t) >= interval) {
              selected.push(f);
              lastTime = t;
            }
          }

          // build track line and calculate actual distance
          const trackLine = selected.map(f => {
            const c = f.geometry.coordinates[0];
            return [c[1], c[0]];
          });

          let actualDist = 0;
          for (let i = 1; i < trackLine.length; i++) {
            actualDist += haversine(trackLine[i-1][0], trackLine[i-1][1],
                                    trackLine[i][0], trackLine[i][1]);
          }

          // GC distance from start to end of track
          const startPos = trackLine[trackLine.length - 1];
          const endPos = trackLine[0];
          const gcDist = haversine(startPos[0], startPos[1], endPos[0], endPos[1]);

          L.polyline(trackLine, {color: 'red', weight: 2, opacity: 0.6}).addTo(trackLayer);

          // markers and crow lines
          let latestPos, latestTime;
          selected.forEach((f, i) => {
            const coords = f.geometry.coordinates[0];
            const pos = [coords[1], coords[0]];
            const dt = new Date(f.properties.datetime);
            const opacity = 1 - (i / selected.length) * 0.7;

            if (i === 0) {
              latestPos = pos;
              latestTime = dt;
              L.marker(pos, {icon: L.divIcon({html: 'ðŸš¢', className: '', iconSize: [24, 24]})})
                .addTo(trackLayer).bindPopup('Nuyina<br>' + dt.toLocaleString());
            } else {
              L.circleMarker(pos, {radius: 5, fillColor: 'red', fillOpacity: opacity,
                                   stroke: false}).addTo(trackLayer);
            }

            // crow line to target
            if (showCrow) {
              const targetPos = [target.lat, target.lon];
              if (useGC) {
                L.geodesic([pos, targetPos], {color: 'blue', weight: 1, opacity: opacity * 0.5}).addTo(trackLayer);
              } else {
                L.polyline([pos, targetPos], {color: 'blue', weight: 1, opacity: opacity * 0.5, dashArray: '3,6'}).addTo(trackLayer);
              }
            }
          });

          // fit bounds
          const bounds = L.latLngBounds([target.lat, target.lon], latestPos);
          trackLine.forEach(p => bounds.extend(p));
          map.fitBounds(bounds, {padding: [50, 50]});

          // distance to target
          const distToTarget = haversine(latestPos[0], latestPos[1], target.lat, target.lon);

          // ratio
          const ratio = gcDist > 0 ? ((actualDist / gcDist - 1) * 100).toFixed(1) : 0;

          document.getElementById('info').innerHTML =
            `<b>${latestTime.toLocaleString()}</b><br>` +
            `${distToTarget.toFixed(1)} km to ${target.name}`;

          document.getElementById('stats').innerHTML =
            `${selected.length} points<br>` +
            `Track: ${actualDist.toFixed(0)} km<br>` +
            `GC: ${gcDist.toFixed(0)} km<br>` +
            `Extra: +${ratio}%`;
        })
        .catch(e => document.getElementById('info').innerHTML = 'Error: ' + e);
    }

    // ---- Event listeners ----
    document.getElementById('refresh').addEventListener('click', loadTrack);

    document.getElementById('count').addEventListener('input', () => {
      document.getElementById('countVal').textContent = document.getElementById('count').value;
    });

    document.getElementById('interval').addEventListener('input', () => {
      document.getElementById('intervalVal').textContent = document.getElementById('interval').value;
    });

    document.getElementById('showCrow').addEventListener('change', loadTrack);
    document.getElementById('useGC').addEventListener('change', loadTrack);

    document.getElementById('voyage').addEventListener('change', () => {
      // adjust defaults based on voyage
      const voyageId = document.getElementById('voyage').value;
      if (voyageId !== 'live') {
        // bump up record count for historical voyages
        document.getElementById('count').value = 20000;
        document.getElementById('countVal').textContent = '20000';
        document.getElementById('interval').value = 120;
        document.getElementById('intervalVal').textContent = '120';
      } else {
        document.getElementById('count').value = 500;
        document.getElementById('countVal').textContent = '500';
        document.getElementById('interval').value = 60;
        document.getElementById('intervalVal').textContent = '60';
      }
      loadTrack();
    });

    document.getElementById('target').addEventListener('change', (e) => {
      const val = e.target.value;
      if (val === 'custom') {
        document.getElementById('customCoords').style.display = 'block';
      } else {
        document.getElementById('customCoords').style.display = 'none';
        target = JSON.parse(val);
        loadTrack();
      }
    });

    document.getElementById('applyCustom').addEventListener('click', () => {
      const lat = parseFloat(document.getElementById('customLat').value);
      const lon = parseFloat(document.getElementById('customLon').value);
      if (!isNaN(lat) && !isNaN(lon)) {
        target = { lat, lon, name: `Custom (${lat.toFixed(2)}, ${lon.toFixed(2)})` };
        loadTrack();
      }
    });

    // ---- Init ----
    loadVoyages().then(() => loadTrack());
  </script>
</body>
</html>
